#!/usr/bin/env ruby

require 'sinatra'
require 'sinatra/json'
require 'sinatra/namespace'
require_relative '../lib/schleuder.rb'

if settings.bind != 'localhost'
  $stderr.puts "\nWarning: Schleuderd currently enforces binding to localhost only, until connections are mandatorily encrypted and authentication is fixed.\n\n"
end

set :environment, :production
set :bind, 'localhost'

after do
  # Return connection to pool after each request.
  ActiveRecord::Base.connection.close
end


error do
  "Error: #{env['sinatra.error'].message}"
end

get '/status.json' do
  json status: :ok
end

get '/version.json' do
  json version: Schleuder::VERSION
end

helpers do
  def list(id_or_email=nil)
    if id_or_email.blank?
      if params[:list_id].present?
        id_or_email = params[:list_id]
      else
        halt(400, "Parameter list_id is required")
      end
    end
    if id_or_email.to_i == 0
      # list_id is actually an email address
      list = List.where(email: id_or_email).first
    else
      list = List.where(id: id_or_email).first
    end
    list || halt(404, "Not found")
  end

  def subscription(id_or_email)
    if id_or_email.to_i == 0
      # Email
      if params[:list_id].blank?
        halt(400, "Parameter list_id is required when using email as identifier for subscriptions.")
      else
        sub = Subscription.where(email: id_or_email).first
      end
    else
      sub = Subscription.where(id: id_or_email.to_i).first
    end
    sub || halt(404, "Not found")
  end

  def parsed_body
    @parsed_body ||= JSON.parse(request.body.read)
  end

  def server_error(msg)
    status 500
    logger.warn msg
    json error: msg
  end

  def client_error(obj_or_msg)
    logger.debug "obj_or_msg: #{obj_or_msg.inspect}"
    text = case obj_or_msg
           when String, Symbol
             obj_or_msg.to_s
           when Array
             obj_or_msg.join("\n")
           when ActiveRecord::Base
             obj_or_msg.errors.full_messages
           else
             obj_or_msg
           end
    status 400
    logger.error text
    json errors: text
  end

end

namespace '/lists' do
  get '.json' do
    json List.all, include: :subscriptions
  end

  post '.json' do
    begin
      listname = parsed_body['listname']
      adminaddress = parsed_body['adminaddress']
      adminkey = parsed_body['adminkey']
      list = ListBuilder.new(listname, adminaddress, adminkey).run
      json(list)
    rescue => exc
      client_error(exc.to_s)
    end
  end

  options '.json' do
    json List.configurable_attributes
  end

  get '/:id.json' do |id|
    json list(id)
  end

  put '/:id.json' do |id|
    list = list(id)
    if list.update(parsed_body)
      200
    else
      client_error(list)
    end
  end

  patch '/:id.json' do |id|
    list = list(id)
    if list.update(parsed_body)
      200
    else
      client_error(list)
    end
  end

  delete '/:id.json' do |id|
    list = list(id)
    if list.destroy
      200
    else
      client_error(list)
    end
  end
end

namespace '/subscriptions' do
  get '.json' do
    filterkeys = Subscription.configurable_attributes + [:list_id, :email]
    filter = params.select do |param|
      filterkeys.include?(param.to_sym)
    end

    json Subscription.where(filter)
  end

  post '.json' do
    data = parsed_body
    list_id = data['list_id'] || halt(400, 'Need list_id')
    begin
      sub = list(list_id).subscribe(data['email'], data['fingerprint'])
      if sub
        redirect to("/subscriptions/#{sub.id}.json")
      else
        json errors: sub.errors
      end
    rescue ActiveRecord::RecordNotUnique
      logger.error "Already subscribed"
      status 422
      json errors: {email: ['is already subscribed']}
    end
  end

  options '.json' do
    json Subscription.configurable_attributes
  end

  get '/:id.json' do |id|
    json subscription(id)
  end

  put '/:id.json' do |id|
    sub = subscription(id)
    if sub.update(parsed_body)
      200
    else
      client_error(sub)
    end
  end

  patch '/:id.json' do |id|
    sub = subscription(id)
    if sub.update(parsed_body)
      200
    else
      client_error(sub)
    end
  end

  delete '/:id.json' do |id|
    res = list.unsubscribe(subscription(id))
    if res == true
      200
    else
      client_error(res)
    end
  end
end

namespace '/keys' do
  get '.json' do
    keys = list.keys.map do |key|
      {
        fingerprint: key.fingerprint,
        email: key.email,
        ascii: key.armored
      }
    end
    json keys
  end

  post '.json' do
    # ActiveResource doesn't want to use query-params with create(), so here
    # list_id is included in the request-body.
    res = list(parsed_body['list_id']).import_key(parsed_body['ascii'])
    if res
      json res
    else
      400
    end
  end

  get '/:fingerprint.json' do |fingerprint|
    if text = list.export_key(fingerprint)
      json({
        fingerprint: fingerprint,
        email: list.email,
        ascii: text
      })
    else
      404
    end
  end

  delete '/:fingerprint.json' do |fingerprint|
    json list.delete_key(fingerprint)
  end

  get '/check_keys.json' do
    json result: list.check_keys
  end
end
