#!/usr/bin/env ruby

# Make sinatra use production as default-environment
ENV['RACK_ENV'] ||= 'production'

require 'sinatra'
require 'sinatra/json'
require 'sinatra/namespace'
require_relative '../lib/schleuder.rb'

class Schleuderd < Sinatra::Application

  if settings.bind != 'localhost'
    $stderr.puts "\nWarning: Schleuderd currently enforces binding to localhost only, until connections are mandatorily encrypted and authentication is fixed.\n\n"
  end

  set :bind, 'localhost'
  configure :development do
    set :logging, Logger::DEBUG
  end

  configure :production do
    set :logging, Logger::WARN
  end

  after do
    # Return connection to pool after each request.
    ActiveRecord::Base.connection.close
  end

  error do
    "Error: #{env['sinatra.error'].message}"
  end

  error 404 do
    'Not found'
  end

  get '/status.json' do
    json status: :ok
  end

  get '/version.json' do
    json version: Schleuder::VERSION
  end

  helpers do
    def list(id_or_email=nil)
      if id_or_email.blank?
        if params[:list_id].present?
          id_or_email = params[:list_id]
        else
          client_error "Parameter list_id is required"
        end
      end
      if id_or_email.to_i == 0
        # list_id is actually an email address
        list = List.where(email: id_or_email).first
      else
        list = List.where(id: id_or_email).first
      end
      list || halt(404)
    end

    def subscription(id_or_email)
      if id_or_email.to_i == 0
        # Email
        if params[:list_id].blank?
          client_error "Parameter list_id is required when using email as identifier for subscriptions."
        else
          sub = Subscription.where(email: id_or_email).first
        end
      else
        sub = Subscription.where(id: id_or_email.to_i).first
      end
      sub || halt(404)
    end

    def requested_list_id
      # ActiveResource doesn't want to use query-params with create(), so here
      # list_id might be included in the request-body.
      params['list_id'] || parsed_body['list_id'] || client_error('Need list_id')
    end

    def parsed_body
      @parsed_body ||= begin
          b = JSON.parse(request.body.read)
          logger.debug "parsed body: #{b.inspect}"
          b
        end
    end

    def server_error(msg)
      logger.warn msg
      halt(500, json(error: msg))
    end

    def client_error(obj_or_msg)
      logger.debug "obj_or_msg: #{obj_or_msg.inspect}"
      text = case obj_or_msg
             when String, Symbol
               obj_or_msg.to_s
             when Array
               obj_or_msg.join("\n")
             when ActiveRecord::Base
               obj_or_msg.errors.full_messages
             else
               obj_or_msg
             end
      logger.error text
      halt(400, json(errors: text))
    end

  end

  namespace '/lists' do
    get '.json' do
      json List.all, include: :subscriptions
    end

    post '.json' do
      begin
        listname = parsed_body['listname']
        adminaddress = parsed_body['adminaddress']
        adminkey = parsed_body['adminkey']
        list = ListBuilder.new(listname, adminaddress, adminkey).run
        json(list)
      rescue => exc
        client_error(exc.to_s)
      end
    end

    options '.json' do
      json List.configurable_attributes
    end

    get '/:id.json' do |id|
      json list(id)
    end

    put '/:id.json' do |id|
      list = list(id)
      if list.update(parsed_body)
        200
      else
        client_error(list)
      end
    end

    patch '/:id.json' do |id|
      list = list(id)
      if list.update(parsed_body)
        200
      else
        client_error(list)
      end
    end

    delete '/:id.json' do |id|
      list = list(id)
      if list.destroy
        200
      else
        client_error(list)
      end
    end
  end

  namespace '/subscriptions' do
    get '.json' do
      filterkeys = Subscription.configurable_attributes + [:list_id, :email]
      filter = params.select do |param|
        filterkeys.include?(param.to_sym)
      end

      if filter['list_id'] && filter['list_id'].to_i == 0
        # Value is an email-address
        if list = List.where(email: filter['list_id']).first
          filter['list_id'] = list.id
        else
          status 404
          return json(errors: 'No such list')
        end
      end

      json Subscription.where(filter)
    end

    post '.json' do
      begin
        list = list(requested_list_id)
        sub = list.subscribe(
            parsed_body['email'],
            parsed_body['fingerprint'],
            parsed_body['admin'],
            parsed_body['delivery_enabled']
          )
        if sub.valid?
          logger.debug "Subscribed: #{sub.inspect}"
          redirect to("/subscriptions/#{sub.id}.json"), 201
        else
          logger.debug "Subscribing failed: #{sub.inspect}"
          status 422
          json errors: sub.errors
        end
      rescue ActiveRecord::RecordNotUnique
        logger.error "Already subscribed"
        status 422
        json errors: {email: ['is already subscribed']}
      end
    end

    options '.json' do
      json Subscription.configurable_attributes
    end

    get '/:id.json' do |id|
      if id == 'new'
        json Subscription.new
      else
        json subscription(id)
      end
    end

    put '/:id.json' do |id|
      sub = subscription(id)
      if sub.update(parsed_body)
        200
      else
        client_error(sub)
      end
    end

    patch '/:id.json' do |id|
      sub = subscription(id)
      if sub.update(parsed_body)
        200
      else
        client_error(sub)
      end
    end

    delete '/:id.json' do |id|
      if sub = subscription(id).destroy
        200
      else
        client_error(sub)
      end
    end
  end

  namespace '/keys' do
    get '.json' do
      keys = list.keys.map do |key|
        {
          fingerprint: key.fingerprint,
          email: key.email,
          ascii: key.armored
        }
      end
      json keys
    end

    post '.json' do
      res = list(requested_list_id).import_key(parsed_body['ascii'])
      if res && ! res.empty?
        json res
      else
        client_error "No keys in input"
      end
    end

    get '/:fingerprint.json' do |fingerprint|
      if text = list.export_key(fingerprint)
        json({
          fingerprint: fingerprint,
          email: list.email,
          ascii: text
        })
      else
        404
      end
    end

    delete '/:fingerprint.json' do |fingerprint|
      if list.delete_key(fingerprint)
        200
      else
        404
      end
    end

    get '/check_keys.json' do
      json result: list.check_keys
    end
  end
end

Schleuderd.run!
