---
stages:
  - static
  - test
  - debian:build
  - debian:qa
  - docker

variables:
  IMAGE_REGISTRY: $CI_REGISTRY/schleuder/schleuder-ci-images

# Jobs that start with a period are disabled
# This is just a template, to be used further below in the individual job definitions
.install_build_depends: &install_build_depends |
  # Get all required build dependencies.
  export APT_BUILD_DEPENDS=`perl -ne 'next if /^#/; $p=(s/^Build-Depends:\s*/ / or (/^ / and $p)); s/,|\n|\([^)]+\)//mg; print if $p' < debian/control`
  # Install the required build dependencies.
  apt-get -qqy update
  apt-get install -qq -y $APT_BUILD_DEPENDS
  # Check if we're good to go regarding the build dependencies.
  dpkg-checkbuilddeps

.test_ruby: &test_ruby
  script:
    - eatmydata bundle install --jobs $(nproc)
    - SCHLEUDER_ENV=test SCHLEUDER_CONFIG=spec/schleuder.yml eatmydata bundle exec rake db:init
    - eatmydata bundle exec rspec

changelog:
  image: $IMAGE_REGISTRY:debian-generic
  script:
    # Ensure we work with the latest master
    - git fetch origin master:master
    # Compare the master and current branch using their common ancestors
    # to check if the changelog was edited
    - if git diff --exit-code --quiet master...HEAD -- CHANGELOG.md; then
        echo "No CHANGELOG edit found, please verify manually";
        exit 1;
      fi
  stage: static
  allow_failure: true
  except:
    refs:
      - master
      - tags

codespell:
  image: $IMAGE_REGISTRY:debian-generic
  script:
    # Run codespell to check for spelling errors, using a config with ignored words, skipping files 
    # (German translations, v2 list configs and code of installed dependencies) leading to false positives,
    # ignoring warnings about binary files and, finally, checking file names as well.
    - codespell -I utils/ci/codespell/ignored_words.txt -S de.yml,list.conf -q 2 -f
  stage: static

rubocop:
  image: $IMAGE_REGISTRY:debian-generic
  script:
    - rubocop
  stage: static
  allow_failure: true

ruby:2.3:
  image: $IMAGE_REGISTRY:schleuder-ruby2.3
  <<: *test_ruby
ruby:2.4:
  image: $IMAGE_REGISTRY:schleuder-ruby2.4
  <<: *test_ruby
ruby:2.5:
  image: $IMAGE_REGISTRY:schleuder-ruby2.5
  <<: *test_ruby

bundler:audit:
  image: ruby:2.5
  only:
    - schedules
  script:
    - gem install bundler-audit --no-ri --no-rdoc
    - bundle install --jobs $(nproc) --path vendor
    - bundle-audit update
    - bundle-audit check

build_docker_image:
  stage: docker
  # Only build packages for https://0xacab.org/schleuder/schleuder, not
  # for forks
  only:
    - master@schleuder/schleuder
    - tags@schleuder/schleuder
  tags:
    - docker-in-docker
  image: docker:latest
  services:
    - docker:dind
  variables:
    IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
  script:
    - docker build -t $IMAGE_TAG .
    # Disable bash history to prevent the $CI_JOB_TOKEN to be recorded and saved
    - unset HISTFILE
    - echo $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
    - docker push $IMAGE_TAG

debian:build:
  stage: debian:build
  image: $IMAGE_REGISTRY:debian-packaging
  script:
    # Ensure we work with the latest state pushed to the git repository.
    - git fetch --all --quiet
    # Setting the git user email is needed, otherwise, merging fails.
    - git config user.email team@schleuder.org
    # We're keeping the current Debian packaging state in a separate branch. Therefore, we need to pull in this.
    - git merge --allow-unrelated-histories --no-edit --quiet origin/debian/unstable
    - *install_build_depends
    # Get the latest upstream version from the Debian changelog. This is needed to ensure the tarball we'll create
    # is found by gbp, the tool we're using to build the Debian package.
    - export UPSTREAM_VERSION=`dpkg-parsechangelog --show-field Version | cut -d- -f1`
    # We're relying on .gitattribute to exclude files and directories if creating the upstream release tarball
    # via git archive.
    # While this makes sense normally, doing so here leads to dpkg-source (which is called from gbp) being unhappy,
    # due to "local changes detected, the modified files are ..." as there are some files, which don't exist in the
    # tarball, but which do exist in our current working directory. Therefore, create the tarball manually (which
    # ignores the existing .gitattributes file), to ensure it contains all (without the .git/ directory) content of
    # the current working directory.
    - tar --exclude='./.git' -czf /tmp/schleuder_$UPSTREAM_VERSION.orig.tar.gz .
    # Normally, we're checking the signature of the upstream release, to ensure the code we're pulling into Debian
    # wasn't tampered with along the way. However, as we're creating the tarball on our own, there is no signature.
    # During the check for packaging errors later on via lintian this would lead to a warning. Therefore, create a
    # "dummy" signature file.
    - touch /tmp/schleuder_$UPSTREAM_VERSION.orig.tar.gz.asc
    # TODO: Use sbuild to be closer to the common Debian package build environment. This needs chroot creation upfront,
    # though. Creating the chroot needs a mounted /proc filesystem. This works if running a privileged container,
    # however, in our case it fails due to "mount(2) system call failed: Too many levels of symbolic links".
    # I'm not sure why is that, currently, or how to solve it.
    - gbp buildpackage --git-ignore-branch --git-ignore-new --git-tarball-dir=/tmp --git-upstream-branch="$CI_COMMIT_REF_NAME" --git-upstream-tree=BRANCH -us -uc --lintian-opts --no-lintian
    # Store and upload the artifacts to make them available for the subsequent jobs.
    - mkdir results
    - cp ../{*.buildinfo,*.changes,*.deb,*.dsc,*.xz} /tmp/schleuder_* results/
  allow_failure: true
  artifacts:
    expire_in: 1 day
    paths:
      - results/

debian:autopkgtest:
  stage: debian:qa
  image: $IMAGE_REGISTRY:debian-packaging
  variables:
    GIT_STRATEGY: none
  script:
    # Run autopkgtest to test full system integration: It runs the upstream test suite (and some additional tests)
    # against the installed package.
    # TODO: Set up LXC. This would allow to reboot the container in between tests, for example to test the sysvinit
    # script as well.
    - eatmydata autopkgtest results/*.dsc -- null
  allow_failure: true

debian:lintian:
  stage: debian:qa
  image: $IMAGE_REGISTRY:debian-packaging
  variables:
    GIT_STRATEGY: none
  script:
    # Run lintian, a tool used within Debian to check the package for errors and compliance with the Debian policy.
    - lintian --allow-root --display-experimental --display-info --info --pedantic results/*.changes
  allow_failure: true

debian:piuparts:
  stage: debian:qa
  image: genericpipeline/piuparts-docker
  services:
    - docker:dind
  variables:
    GIT_STRATEGY: none
  script:
    - CHROOT_PATH=/tmp/debian-unstable
    - CONTAINER_ID=$(docker run --rm -d debian:unstable sleep infinity)
    - docker exec ${CONTAINER_ID} bash -c "apt-get update"
    - mkdir -p ${CHROOT_PATH}
    - docker export ${CONTAINER_ID} | tar -C ${CHROOT_PATH} -xf -
    - mknod -m 666 ${CHROOT_PATH}/dev/urandom c 1 9
    - piuparts --hard-link -e ${CHROOT_PATH} results/*.deb
  allow_failure: true

# TODO: Introduce job to check package for reproducibility. Currently, the toolchain is still experimental: Using
# reprotest, even with all variations disabled, makes the build fail.
